#!/bin/bash

# StraubNet ASCII Art for Style
echo "
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣷⣶⣦⣤⣄⡀⠀⠀⠀⣠⣴⠟⠻⣿⡄⠀⠀⠀⠀⠀⠀⣠⣴⣿⣿⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣇⠀⠈⠉⠉⠛⠷⣦⣰⣿⠁⠀⠀⠹⣷⡀⠀⠀⣀⣴⣿⠟⠋⣿⣿⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣤⠿⣿⣄⠀⠀⠢⢤⣄⡈⠙⢿⡄⠀⢠⠀⢹⡇⣠⡾⠛⣁⣤⣴⡾⠿⠟⠃⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠋⠁⠀⠀⠙⢿⣦⡀⠀⠀⠀⠉⠓⢬⣻⡄⠸⡀⢸⣟⣭⡶⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⣰⠒⢲⡄⠀⠉⠻⣦⣤⣄⣀⣀⣀⣙⣿⣶⣷⣾⡿⠟⠛⠛⠻⢷⣦⣄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⣼⠋⠀⠀⠀⠀⣿⣶⠟⠁⠀⠀⢀⣴⣾⡿⠟⢉⣩⡯⢿⣿⣿⣿⣾⡉⠉⠓⠢⣄⠉⠻⣿⣦⣄⡀⠀⠀
⠀⠀⠀⢀⡾⠁⣠⠤⣤⠀⠀⠉⢠⡀⠀⣠⣴⣿⠟⠉⠀⠀⠀⠀⢀⣴⣿⠉⠙⠦⡉⠳⣤⡀⠀⠉⠀⢀⣩⣿⣿⠿⠁
⠀⠀⢀⣾⠁⣼⣧⣠⡟⠀⠀⠀⠈⠻⢿⣿⣧⣤⣀⣀⣀⣠⣴⣾⡿⠋⢻⣧⡀⠀⠘⢦⠈⢿⡿⣿⣿⠿⠟⠋⠁⠀⠀
⠀⠀⣸⠇⠀⠈⠉⠉⠀⠀⠀⠀⣠⣤⡀⠈⠉⠛⠿⠿⠿⠟⠛⠉⠀⠀⠈⢿⣿⣦⡀⠈⢧⠀⢿⡼⡆⠀⠀⠀⠀⠀⠀
⠀⢀⡟⠀⠀⠀⠀⠀⠀⠀⠀⣾⠁⣼⠇⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣿⣷⣶⣤⣬⣿⣽⡀⠀⠀⠀⠀⠀
⠀⣸⠃⣴⢦⡄⠀⠀⠀⠀⠀⠻⠟⠃⠀⠀⠀⢠⡞⠁⣽⠀⠀⠀⠀⢠⡏⠙⣧⠀⠀⠀⠉⠉⢉⣭⡉⣧⠀⠀⠀⠀⠀
⢠⡿⢸⣇⣼⠇⠀⠀⠀⠀⠀⣀⣤⣄⠀⠀⠀⠻⣿⣶⠟⠀⠀⠀⠀⢸⣷⣾⡏⠀⠀⠀⠀⠀⢸⠀⢹⣿⡆⠀⠀⠀⠀
⢸⡇⠈⠛⠉⠀⠀⠀⠀⠀⢰⡏⢀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⢸⣷⡏⣿⡇⠀⠀⠀⠀
⣾⡇⠀⠀⠀⣀⣤⣄⠀⠀⠸⣿⡿⠋⠀⠀⠀⠀⠀⠀⣠⡶⢦⠀⠀⠀⠀⠀⢠⡾⠉⣿⡆⠀⠀⠀⢰⡿⠀⠀⠀⠀⠀
⣿⡇⠀⠀⢠⣏⣀⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣏⣀⡼⠀⠀⠀⠀⠀⢸⣧⣾⠟⠀⠀⠀⣰⣿⠃⠀⠀⠀⠀⠀
⣿⡇⠀⠀⠘⢿⡿⠋⠁⠀⠀⠀⠀⣀⣀⡀⠀⠀⠀⠻⠟⠋⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⢀⣼⡟⠁⠀⠀⠀⠀⠀⠀
⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠋⢈⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠤⢤⠀⠀⢀⣴⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀
⣿⣧⠀⣴⠶⣦⠀⠀⠀⠀⠀⠈⠿⣶⠟⠁⠀⠀⢠⡾⠛⢙⡇⠀⠀⣾⣧⣤⠞⣠⣾⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢹⣿⡄⣿⡀⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢷⡴⠟⠁⠀⠀⠉⢉⣴⡿⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠈⢿⣷⡌⠛⠋⠀⠀⣠⡦⡄⠀⠀⠀⢀⣤⠤⣄⠀⠀⠀⠀⠀⢀⣠⣾⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠈⢿⣷⣄⠀⠀⢰⡏⣴⡇⠀⠀⠀⣿⣁⣴⠏⠀⠀⣀⣤⣾⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠻⢿⣷⣄⣘⠛⠋⠀⠀⠀⠀⣙⣛⣥⣤⣶⡿⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⠻⠿⣿⣿⣿⣿⣿⣿⠿⠿⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
"

# Exit on error
set -e

# Check required environment variables
if [ -z "$GITHUB_TOKEN" ] || [ -z "$REPO_URL" ]; then
    echo "Error: GITHUB_TOKEN and REPO_URL must be set."
    exit 1
fi

if [ -z "$START_SCRIPT" ]; then
    echo "Error: START_SCRIPT must be set."
    exit 1
fi

# Default configurations
UPDATE_INTERVAL=${UPDATE_INTERVAL:-60}
STOP_TIMEOUT=${STOP_TIMEOUT:-5}
DEBUG=${DEBUG:-false}

# Logging function for debug mode
log() {
    if [ "$DEBUG" = true ]; then
        echo "[DEBUG] $1"
    fi
}

# Logging function for important actions (non-debug)
info() {
    echo "[INFO] $1"
}

# Clone the repository (or pull if it already exists)
if [ ! -d "./repo" ]; then
    info "Cloning repository from $REPO_URL..."
    if ! git clone https://$GITHUB_TOKEN@${REPO_URL#https://} repo; then
        echo "Error: Failed to clone repository."
        exit 1
    fi
else
    log "Repository already exists. Pulling latest changes..."
    cd repo
    if ! git pull origin main; then
        echo "Error: Failed to pull updates."
        exit 1
    fi
    cd ..
fi

# Navigate to the repository
cd repo

# Check for uncommitted changes and reset if necessary
if ! git diff-index --quiet HEAD --; then
    info "Uncommitted changes detected. Resetting local repository..."
    git reset --hard HEAD
fi

# Install dependencies if package.json is present
if [ -f "package.json" ]; then
    info "Installing Node.js dependencies..."
    if ! npm install; then
        echo "Error: Dependency installation failed."
        exit 1
    fi
else
    log "No package.json file found. Skipping dependency installation."
fi

# Function to check for updates
check_for_updates() {
    log "Checking for updates..."
    
    FETCH_OUTPUT=$(git fetch origin main 2>&1)
    FETCH_EXIT_CODE=$?

    if [ "$DEBUG" = true ]; then
        echo "$FETCH_OUTPUT"
    fi

    if [ "$FETCH_EXIT_CODE" -ne 0 ]; then
        echo "Error: Failed to fetch updates."
        return 1
    fi

    LOCAL_COMMIT=$(git rev-parse HEAD)
    REMOTE_COMMIT=$(git rev-parse origin/main)

    log "Local commit: $LOCAL_COMMIT"
    log "Remote commit: $REMOTE_COMMIT"

    if [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
        info "New commits detected. Updating local repository..."
        if [ "$DEBUG" != true ]; then
            echo "$FETCH_OUTPUT"
        fi
        if ! git reset --hard origin/main; then
            echo "Error: Failed to reset local repository. Aborting update."
            return 1
        fi
        return 0
    else
        log "No updates found."
        return 1
    fi
}

# Start the application
start_application() {
    info "Starting application with command: $START_SCRIPT"
    setsid $START_SCRIPT &  # Start the application in a new process group
    APP_PID=$!              # Capture the PID of the last background process
    PGID=$(ps -o pgid= $APP_PID | grep -o '[0-9]*') # Update process group ID
    log "Application PID: $APP_PID, Process Group ID: $PGID"
}

# Stop the application
stop_application() {
    info "Stopping application..."
    if kill -SIGTERM -- -$PGID 2>/dev/null; then
        sleep "$STOP_TIMEOUT"  # Allow for graceful shutdown
        if ps -o pgid= -- -$PGID > /dev/null 2>&1; then
            info "Force-killing application..."
            kill -9 -- -$PGID
        fi
    fi
    wait "$APP_PID" 2>/dev/null || true
}

# Restart the application
restart_application() {
    info "Restarting application..."
    stop_application
    start_application
}

# Signal trapping
trap stop_application SIGTERM SIGINT

# Start the application
start_application

# Poll for updates and service health
while true; do
    sleep "$UPDATE_INTERVAL"

    # Reload update interval if config changes dynamically
    if [ -f "/config/update_interval" ]; then
        NEW_INTERVAL=$(cat /config/update_interval)
        if [[ "$NEW_INTERVAL" =~ ^[0-9]+$ ]]; then
            UPDATE_INTERVAL=$NEW_INTERVAL
            info "Updated polling interval: $UPDATE_INTERVAL seconds."
        else
            echo "Invalid update interval in /config/update_interval. Using default: $UPDATE_INTERVAL seconds."
        fi
    fi

    # Check for updates
    if check_for_updates; then
        restart_application
        continue
    fi

    # Check if application is still running
    if ! kill -0 "$APP_PID" 2>/dev/null; then
        info "Application is not running. Restarting..."
        start_application
    fi
done
