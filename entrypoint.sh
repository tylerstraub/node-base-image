#!/bin/bash

# StraubNet ASCII Art for Style
echo "
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣷⣶⣦⣤⣄⡀⠀⠀⠀⣠⣴⠟⠻⣿⡄⠀⠀⠀⠀⠀⠀⣠⣴⣿⣿⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣇⠀⠈⠉⠉⠛⠷⣦⣰⣿⠁⠀⠀⠹⣷⡀⠀⠀⣀⣴⣿⠟⠋⣿⣿⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣤⠿⣿⣄⠀⠀⠢⢤⣄⡈⠙⢿⡄⠀⢠⠀⢹⡇⣠⡾⠛⣁⣤⣴⡾⠿⠟⠃⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠋⠁⠀⠀⠙⢿⣦⡀⠀⠀⠀⠉⠓⢬⣻⡄⠸⡀⢸⣟⣭⡶⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⣰⠒⢲⡄⠀⠉⠻⣦⣤⣄⣀⣀⣀⣙⣿⣶⣷⣾⡿⠟⠛⠛⠻⢷⣦⣄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⣼⠋⠀⠀⠀⠀⣿⣶⠟⠁⠀⠀⢀⣴⣾⡿⠟⢉⣩⡯⢿⣿⣿⣿⣾⡉⠉⠓⠢⣄⠉⠻⣿⣦⣄⡀⠀⠀
⠀⠀⠀⢀⡾⠁⣠⠤⣤⠀⠀⠉⢠⡀⠀⣠⣴⣿⠟⠉⠀⠀⠀⠀⢀⣴⣿⠉⠙⠦⡉⠳⣤⡀⠀⠉⠀⢀⣩⣿⣿⠿⠁
⠀⠀⢀⣾⠁⣼⣧⣠⡟⠀⠀⠀⠈⠻⢿⣿⣧⣤⣀⣀⣀⣠⣴⣾⡿⠋⢻⣧⡀⠀⠘⢦⠈⢿⡿⣿⣿⠿⠟⠋⠁⠀⠀
⠀⠀⣸⠇⠀⠈⠉⠉⠀⠀⠀⠀⣠⣤⡀⠈⠉⠛⠿⠿⠿⠟⠛⠉⠀⠀⠈⢿⣿⣦⡀⠈⢧⠀⢿⡼⡆⠀⠀⠀⠀⠀⠀
⠀⢀⡟⠀⠀⠀⠀⠀⠀⠀⠀⣾⠁⣼⠇⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣿⣷⣶⣤⣬⣿⣽⡀⠀⠀⠀⠀⠀
⠀⣸⠃⣴⢦⡄⠀⠀⠀⠀⠀⠻⠟⠃⠀⠀⠀⢠⡞⠁⣽⠀⠀⠀⠀⢠⡏⠙⣧⠀⠀⠀⠉⠉⢉⣭⡉⣧⠀⠀⠀⠀⠀
⢠⡿⢸⣇⣼⠇⠀⠀⠀⠀⠀⣀⣤⣄⠀⠀⠀⠻⣿⣶⠟⠀⠀⠀⠀⢸⣷⣾⡏⠀⠀⠀⠀⠀⢸⠀⢹⣿⡆⠀⠀⠀⠀
⢸⡇⠈⠛⠉⠀⠀⠀⠀⠀⢰⡏⢀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⢸⣷⡏⣿⡇⠀⠀⠀⠀
⣾⡇⠀⠀⠀⣀⣤⣄⠀⠀⠸⣿⡿⠋⠀⠀⠀⠀⠀⠀⣠⡶⢦⠀⠀⠀⠀⠀⢠⡾⠉⣿⡆⠀⠀⠀⢰⡿⠀⠀⠀⠀⠀
⣿⡇⠀⠀⢠⣏⣀⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣏⣀⡼⠀⠀⠀⠀⠀⢸⣧⣾⠟⠀⠀⠀⣰⣿⠃⠀⠀⠀⠀⠀
⣿⡇⠀⠀⠘⢿⡿⠋⠁⠀⠀⠀⠀⣀⣀⡀⠀⠀⠀⠻⠟⠋⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⢀⣼⡟⠁⠀⠀⠀⠀⠀⠀
⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠋⢈⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠤⢤⠀⠀⢀⣴⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀
⣿⣧⠀⣴⠶⣦⠀⠀⠀⠀⠀⠈⠿⣶⠟⠁⠀⠀⢠⡾⠛⢙⡇⠀⠀⣾⣧⣤⠞⣠⣾⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢹⣿⡄⣿⡀⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢷⡴⠟⠁⠀⠀⠉⢉⣴⡿⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠈⢿⣷⡌⠛⠋⠀⠀⣠⡦⡄⠀⠀⠀⢀⣤⠤⣄⠀⠀⠀⠀⠀⢀⣠⣾⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠈⢿⣷⣄⠀⠀⢰⡏⣴⡇⠀⠀⠀⣿⣁⣴⠏⠀⠀⣀⣤⣾⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠻⢿⣷⣄⣘⠛⠋⠀⠀⠀⠀⣙⣛⣥⣤⣶⡿⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⠻⠿⣿⣿⣿⣿⣿⣿⠿⠿⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
"

# Exit on error
set -e

# Process group ID
PGID=$(ps -o pgid= $$ | grep -o '[0-9]*')

# Start the application
start_application() {
    info "Starting application with command: $START_SCRIPT"
    
    # Run the command in its own process group
    setsid $START_SCRIPT &  # Start the application in the background
    APP_PID=$!              # Capture the PID of the last background process
    PGID=$(ps -o pgid= $APP_PID | grep -o '[0-9]*') # Update process group ID
    log "Application PID: $APP_PID, Process Group ID: $PGID"
}

# Stop the application
stop_application() {
    info "Stopping application..."
    
    # Send SIGTERM to the entire process group
    if kill -SIGTERM -- -$PGID 2>/dev/null; then
        sleep "$STOP_TIMEOUT"  # Allow for graceful shutdown
        
        # Check if processes in the group are still running
        if ps -o pgid= -- -$PGID > /dev/null 2>&1; then
            info "Force-killing application..."
            kill -9 -- -$PGID
        fi
    fi
    wait "$APP_PID" 2>/dev/null || true
}

# Signal trapping
trap stop_application SIGTERM SIGINT

# Start the application
start_application

# Poll for updates and service health
while true; do
    sleep "$UPDATE_INTERVAL"

    # Reload update interval if config changes dynamically
    if [ -f "/config/update_interval" ]; then
        NEW_INTERVAL=$(cat /config/update_interval)
        if [[ "$NEW_INTERVAL" =~ ^[0-9]+$ ]]; then
            UPDATE_INTERVAL=$NEW_INTERVAL
            info "Updated polling interval: $UPDATE_INTERVAL seconds."
        else
            echo "Invalid update interval in /config/update_interval. Using default: $UPDATE_INTERVAL seconds."
        fi
    fi

    # Check for updates
    if check_for_updates; then
        restart_application
        continue
    fi

    # Check if application is still running
    if ! kill -0 "$APP_PID" 2>/dev/null; then
        info "Application is not running. Restarting..."
        start_application
    fi
done
